<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <p>
      <a href="https://leetcode-cn.com/problems/valid-parentheses/"
        >leetCode20</a
      >
    </p>
    <p>
      <a href="https://leetcode-cn.com/problems/min-stack/">leetCode 155</a>
    </p>
    <p>
      <a
        href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/"
        >leetCode 1047</a
      >
    </p>
    <p>
      <a href="https://leetcode-cn.com/problems/baseball-game/submissions/"
        >LeetCode 682</a
      >
    </p>

    <p>
      <a href="https://leetcode-cn.com/problems/backspace-string-compare/">
        leetCode844</a
      >
    </p>
    <p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">LeetCode 150</a></p>
  </head>
  <body>
    <script src="../index.js"></script>
    <!--  <script>
      // leetCode20
      // 用例

      /**
       * * 解题思路：
       * *成对括号有如下特点：
       * * 1. 字符串长度必为偶数
       * * 2. 如果是并列关系的括号,如str1:必将依次成对
       * * 3. 如果是嵌套关系的括号,如str2:括号必将从最内层到最外层依次成对,也就是说,最内层的一组括号必然是连续成对的。
       *
       * * 使用栈结题的思路：
       * * 从字符串第一位开始判断，如果栈为空，则直接进栈(push)
       * * 如果栈不为空，判断当前元素是否和栈顶元素(peek)配对
       * * 如果当前元素和栈顶元素配对，则对栈顶元素进行出栈(pop)操作
       * * 如果当前元素和栈顶元素不配对，则将该元素压入栈中(push)
       * * 在遍历操作结束后，如果栈为空(isEmpty)，则证明字符串为成对括号;反之不是成对括号。
       */

      let str = '[]';

      let str1 = '[]{}()';

      let str2 = '[{}]';

      let str3 = '[{(}]';

      var isValid = function(s) {
        let stack = [];
        if (s.length % 2 !== 0) return false;
        for (let i of s) {
          if (!stack.length) {
            stack.push(i);
          } else {
            isMatch(stack[stack.length - 1], i) ? stack.pop() : stack.push(i);
          }
        }
        return stack.length === 0;
      };

      const isMatch = function(c1, c2) {
        return (
          (c1 === '(' && c2 === ')') ||
          (c1 === '[' && c2 === ']') ||
          (c1 === '{' && c2 === '}')
        );
      };

      console.log(isValid(str));
      console.log(isValid(str1));
      console.log(isValid(str2));
      console.log(isValid(str3));
    </script> -->
    <!--  <script>
      // leetCode 155 最小栈

      /**
       * * 解题思路：
       * * 由于题目要求getMin的时间复杂度为常数
       * * 所以可以采取利用辅助栈空间换时间的策略
       * *
       * * 1：辅助栈与数据栈同步
       * * 2：辅助栈为空的时候将数据压入主栈的时候同步压入辅助栈
       * * 3：辅助栈不为空的时候，数据压入主栈的时候，判断当前元素是否小于辅助栈当前栈顶元素(peek)，如果小于栈顶元素，则将当前元素压入辅助栈；否则将当前辅助栈栈顶元素的值再次压入辅助栈
       * * 4: 主栈出栈的时候辅助栈同步出栈(pop)
       * * 5: getMin的时候返回辅助栈的栈顶元素(peek)
       *
       * * 不同步辅助栈的思路
       * * 1: 如果当前元素的值小于等于辅助栈栈顶的元素(peek),则入栈,否则不入栈
       * * 2: 出栈时，如果主栈当前出栈元素和辅助栈出栈元素一致，辅助栈才主栈，否则不出栈
       *
       * 时间复杂度：O(n)
       * 空间复杂度：O(n)
       */

      class MinStack {
        constructor() {
          this.data = [];
          this.MinStack = [];
        }
        /* 入栈 */
        push(item) {
          this.data.push(item);
          if (!this.MinStack.length) {
            this.MinStack.push(item);
          } else {
            if (this.MinStack[this.MinStack.length - 1] > item) {
              this.MinStack.push(item);
            } else {
              this.MinStack.push(this.MinStack[this.MinStack.length - 1]);
            }
          }
        }
        /* 出栈 */
        pop() {
          this.MinStack.pop();
          return this.data.pop();
        }
        /* 查看栈顶元素 */
        top() {
          return this.data[this.data.length - 1];
        }
        getMin() {
          return this.MinStack[this.MinStack.length - 1];
        }
      }

      let minStack = new MinStack();
      minStack.push(-2);
      minStack.push(0);
      minStack.push(-3);
      console.log(minStack.getMin());
      minStack.pop();
      console.log(minStack.top());
      console.log(minStack.getMin());
    </script> -->
    <!--  <script>
      // leetCode 1047
      /**
       * * 此题思路同判断配对括号
       */
      let str = 'abbaccba';
      var removeDuplicates = function(s) {
        let str = s.replace(/[^\w]/g, '').toLowerCase();
        let stack = [];
        for (let i = 0; i < s.length; i++) {
          if (!stack.length) {
            stack.push(s[i]);
          } else {
            if (stack[stack.length - 1] === s[i]) {
              stack.pop();
            } else {
              stack.push(s[i]);
            }
          }
        }
        return stack.join('');
      };

      console.log(removeDuplicates(str));
    </script> -->
    <!--  <script>
      // leetcode 682

      /**
       * * 解题思路：
       * * 本题的题干很清晰，输入值有四种类型分别任:数字，C,D,+
       * * 使用栈解题：遍历字符串,根据不同类型进行相应的操作：
       * * - 如果是数字，则直接将数字压入栈中
       * * - 如果是'D',则将当前栈顶(peek)的值*2后压入栈中
       * * - 如果是'C',并且栈不为空，则将当前栈顶元素(peek)弹出(pop)
       * * - 如果是'+'，则将当前的栈顶元素(peek)出栈并保存，然后将出栈的栈顶元素和出栈后目前的栈顶元素(peek)相加，然后将之前出栈到的栈顶元素和相加后的元素依次入栈(push);
       *
       * * 最后返回栈内元素的的总和即为所得总分。
       */
      let ops = ['5', '-2', '4', 'C', 'D', '9', '+', '+'];

      var calPoints = function(ops) {
        let stack = [];
        for (let option of ops) {
          if (Number(option)) {
            stack.push(Number(option));
          } else {
            switch (option) {
              case 'C':
                if (stack.length) {
                  stack.pop();
                }
                break;
              case 'D':
                stack.push(stack[stack.length - 1] * 2);
                break;
              case '+':
                let peek = Number(stack.pop());
                let newValue;
                if (stack.length > 1) {
                  newValue = Number(peek + Number(stack[stack.length - 1]));
                } else {
                  newValue = Number(peek);
                }
                stack.push(peek);
                stack.push(newValue);
                break;
              default:
                console.error('invalid data');
            }
          }
        }
        let result = 0;
        while (stack.length > 0) {
          result += stack.pop();
        }
        return result;
      };

      console.log(calPoints(ops));
    </script> -->
    <!--  <script>
      // leetCode 844

      // S，T两个字符串，#代表退格。判断是否相等

      // 两个栈，一个栈存放S，一个栈存放T
      // 遍历遇倒字母进行入栈，遇倒#出栈当前栈顶
      // 最后先比较两个栈的size如果相同，则进行下一步判断，否则返回false

      var backspaceCompare = function(S, T) {
        let stack1 = [];
        let stack2 = [];
        for (let i = 0; i < S.length; i++) {
          if (S[i] === '#') {
            stack1.pop();
          } else {
            stack1.push(S[i]);
          }
        }
        for (let i = 0; i < T.length; i++) {
          if (T[i] === '#') {
            stack2.pop();
          } else {
            stack2.push(T[i]);
          }
        }
        if (stack1.length !== stack2.length) return false;
        while (stack1.length) {
          if (stack1.pop() !== stack2.pop()) {
            return false;
          }
        }
        return true;
      };

      console.log(backspaceCompare('ab##', 'c#d#'));
    </script> -->
    <!--  <script>
      // leetCode 150逆波兰表达式求值

      // 逆波兰表达式：传统的四则运算为 a+b = c，逆波兰表达式可以理解为 ab+ = 3
      // 这道题在LeetCode是中等，但实际上应该属于简单题
      // 定义一个用来做四则运算的函数
      // 遍历数组，遇倒数字直接push进栈
      // 遇倒运算符则将数组的peek和前一个元素pop出来传入函数进行计算，将计算的结果push进栈
      // 最终栈内唯一的元素就是我们要求的值
      let arr = ['0', '3', '/'];

      function chooseCaculation(num1, num2, cacu) {
        switch (cacu) {
          case '+':
            return num1 + num2;
            break;
          case '-':
            return num1 - num2;
            break;
          case '*':
            return num1 * num2;
            break;
          case '/':
            return parseInt(num1 / num2);
            break;
          default:
            console.error('invalid value');
            break;
        }
      }

      var evalRPN = function(tokens) {
        let stack = [];
        for (let item of tokens) {
          if (item !== '*' && item !== '-' && item !== '+' && item !== '/') {
            stack.push(item);
          } else {
            let top = Number(stack.pop());
            let prev = Number(stack.pop());
            stack.push(chooseCaculation(prev, top, item));
          }
        }
        return stack[stack.length - 1];
      };
      evalRPN(arr);
    </script> -->
  </body>
</html>
